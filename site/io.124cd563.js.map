{"mappings":"AAEAA,IAAIC,kBAAoB","sources":["./src/js/io.js"],"sourcesContent":["/* Minifier: http://jscompress.com/ */\n\nzip.workerScriptsPath = \"/js/lib/zipjs/\";\n\nconst io = {\n  xmlToJson: function(file, doneCallback, errorCallback) {\n    console.log(\"io.xmlToJson\");\n    zip.createReader(\n      new zip.BlobReader(fileInput.files[0]),\n      function(reader) {\n        console.log(\"Preparing to read XML entries...\");\n        reader.getEntries(function(entries) {\n          if (entries.length == 0) {\n            errorCallback(\"No entries from reader\");\n            return;\n          }\n\n          entries[0].getData(\n            new zip.TextWriter(),\n            function(text) {\n              console.log(\"Converting text to json...\", text);\n              var jsonObject = textToJson(text);\n              reader.close(function() {});\n              doneCallback(jsonObject);\n            },\n            function(current, total) {}\n          );\n        });\n      },\n      function(error) {\n        console.error(\"Error reading ZIP\");\n        console.error(error);\n        errorCallback(\"Could not extract ZIP file\");\n      }\n    );\n  }\n};\n\nfunction textToJson(text) {\n  var parser = new DOMParser();\n  var xmlDom = parser.parseFromString(text, \"text/xml\");\n  var jsTree = getJXONTree(xmlDom);\n  //console.log(jsTree);\n  return jsTree;\n}\n\n// https://developer.mozilla.org/en-US/docs/JXON#Algorithm_.233.3A_a_synthetic_technique\nfunction parseText(sValue) {\n  if (/^\\s*$/.test(sValue)) {\n    return null;\n  }\n  if (/^(?:true|false)$/i.test(sValue)) {\n    return sValue.toLowerCase() === \"true\";\n  }\n  if (isFinite(sValue)) {\n    return parseFloat(sValue);\n  }\n  //this will convert text that contains a dot to bogus dates if (isFinite(Date.parse(sValue))) { return new Date(sValue); }\n  return sValue;\n}\nfunction getJXONTree(oXMLParent) {\n  var vResult = /* put here the default value for empty nodes! */ true,\n    nLength = 0,\n    sCollectedTxt = \"\";\n  /*\n\tif (oParentNode.hasAttributes && oXMLParent.hasAttributes()) {\n\t\tvResult = {};\n\t\tfor (nLength; nLength < oXMLParent.attributes.length; nLength++) {\n\t\t\toAttrib = oXMLParent.attributes.item(nLength);\n\t\t\tvResult[\"@\" + oAttrib.name.toLowerCase()] = parseText(oAttrib.value.trim());\n\t\t}\n\t}\n\t*/\n  if (oXMLParent.hasChildNodes()) {\n    for (\n      var oNode, sProp, vContent, nItem = 0;\n      nItem < oXMLParent.childNodes.length;\n      nItem++\n    ) {\n      oNode = oXMLParent.childNodes.item(nItem);\n      if (oNode.nodeType === 4) {\n        sCollectedTxt += oNode.nodeValue;\n      } /* nodeType is \"CDATASection\" (4) */ else if (oNode.nodeType === 3) {\n        sCollectedTxt += oNode.nodeValue.trim();\n      } /* nodeType is \"Text\" (3) */ else if (\n        oNode.nodeType === 1 &&\n        !oNode.prefix\n      ) {\n        /* nodeType is \"Element\" (1) */\n        if (nLength === 0) {\n          vResult = {};\n        }\n        sProp = oNode.nodeName.toLowerCase();\n        vContent = getJXONTree(oNode);\n        if (vResult.hasOwnProperty(sProp)) {\n          if (vResult[sProp].constructor !== Array) {\n            vResult[sProp] = [vResult[sProp]];\n          }\n          vResult[sProp].push(vContent);\n        } else {\n          vResult[sProp] = vContent;\n          nLength++;\n        }\n      }\n    }\n  }\n  if (sCollectedTxt) {\n    nLength > 0\n      ? (vResult.keyValue = parseText(sCollectedTxt))\n      : (vResult = parseText(sCollectedTxt));\n  }\n  /* if (nLength > 0) { Object.freeze(vResult); } */\n  return vResult;\n}\n"],"names":["zip","workerScriptsPath"],"version":3,"file":"io.124cd563.js.map"}